@startuml
package "Espresso Sequencer Network" as Network {
    component "Sequencer\nNodes" as Nodes
    package CDN {
        component Broker
        component Marshal
        database KeyDB
    }
}

'CDN Layout
Broker -> KeyDB: state
KeyDB -> Marshal: state
Nodes <--> CDN: consensus\nmessages

package "Espresso Sequencer" as Espresso {
    database "Postgres" as DB
    package "Sequencer Node" as Seq {
        component "APIs" {
            port Catchup
            port HTTP
            port Status
            port Submit
            port Query
            port "Hotshot\nEvents\nStream" as Events
            component "HotShot\nQuery\nService" as QS
        }
        component "Networking"{
            component Libp2p
            component "CDN Client"
        }

        package State as State {
            component "State Signer" as Signer
            component "ValidatedState" as Validated
        }
    }
    component "HotShot state\nprover service" as HSProver
    component "HotShot state\nrelay service" as Relay
    component "Builder" as Builder
    Query --> QS
}

Nodes -up-> Catchup: missing\nstate
Nodes <-up-> Libp2p: consensus\nmessages
"CDN Client" <--> CDN: consensus\nmessages

QS --> DB
QS -[hidden]down-> APIs
Signer -down-> Relay: state
Seq -right-> Builder: claim block
Relay --> HSProver: state

Events -> Builder: " " "transactions"
Builder -left-> Seq: block

package "Layer 2s" as L2 {
    component "Rollup 1" as L2_1 {
        component "API (e.g. JSON-RPC)" as L2_1_RPC
        component Executor as L2_1_Exec
        component Prover as L2_1_Prover
        database "State DB" as L2_1_State
    }
}
package "Ethereum Layer 1" as L1 {
    package "Espresso Contracts" as Esp_L1 {
        component "Light Client\nContract" as LC_L1
        component "Fee\nContract" as Fee_L1
    }
    package "Rollup Contracts" as L2_L1 {
        component "Rollup 1\nContract" as L2_1_L1
    }
}

entity User
User -Up-> L2_1_RPC : "transactions,\nstate queries" " "
note top of link
1. Many clients submit
    transactions to each
    L2 simultaneously (for
    clarity only one is
    shown)
end note

L2_1_RPC --> Submit : "transaction\nRollup 1 ID" " "
note top of link
2. L2s forward transactions to sequencer.
end note

Query -up-> L2_1_Exec : Block
note right of link
3. Sequencer produces blocks --
    ordered lists of transactions.
    L2s receive blocks and execute
    transactions for their rollup.
end note

HSProver -down-> LC_L1 : HotShot\nstate\nproof
note right of link
4. Sequencer posts succinct commitment
    to block to L1. Contract verifies proof
    of sequencing (Quorum Certificate)
    then stores the block commitment.
end note

L2_1_Prover -> L2_1_L1 : rollup\nstate\nproof
note bottom of link
5. Rollups post
    updated state
    to L1. ZK-rollups
    include a proof.
end note

LC_L1 -> L2_L1
note bottom of link
6. Rollup contracts read certified sequence
    of block commitments from sequencer
    contract. Verify state transition proofs
    against this sequence (ZKR) or wait for
    fraud proof against this sequence (ORU).
end note

' L2 1 details
L2_1_RPC <-up- L2_1_State : Read state
L2_1_Exec -up-> L2_1_State : Write state
L2_1_Prover <-up- L2_1_State : Read State

Builder --> Fee_L1: deposit\nfee
Fee_L1 -up-> Validated: fee\ndeposits

@enduml
