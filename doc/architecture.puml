@startuml

skinparam package<<Layout>> {
  borderColor Transparent
  backgroundColor Transparent
  fontColor Transparent
  stereotypeFontColor Transparent
}

package "Espresso Sequencer Network" as Network #MistyRose {
    package CDNLayout <<Layout>> {
        component "Other\nSequencer\nNodes" as Nodes
        package CDN {
            component Broker
            component Marshal
            database KeyDB
        }
    }

    'CDN Layout
    Broker -> KeyDB: state
    KeyDB -> Marshal: state
    Nodes <--> CDN: consensus\nmessages

    component "Sequencer Node" as Seq #Bisque {
        database "Postgres" as DB
        package APIs #LightCyan {
            component "Submit" as Submit
            component "Hotshot\nEvents\nStream\n" as EventsStream
            component "Catchup" as Catchup
            component "Status"
            component "Query" as Query
        }
        /'
         ' component "HotShot\nQuery\nService" as QS
         '/
        package HotShot {
            component "Networking"{
                component Libp2p
                component "CDN Client"
            }
            Libp2p -[hidden]left-> "CDN Client"
            component "HotShot Events" as Events
        }

        package State as State {
            component "State Signer" as Signer
            component "ValidatedState" as Validated
        }
    }
    component "HotShot state\nprover service" as HSProver
    component "HotShot state\nrelay service" as Relay
    component "Builder" as Builder
    /'
     ' Query --> QS
     '/
}

Nodes --> Catchup: " " "missing\nstate"
Nodes <--> Libp2p: consensus\nmessages
"CDN Client" <--> CDN: consensus\nmessages

Query --> DB
Signer -down-> Relay: state
Builder --> HotShot: block
Relay --> HSProver: state

Events -up-> EventsStream
Events -down-> Validated
Networking -> Events
EventsStream -> Builder: transactions
Validated -up-> DB
Catchup --> DB

package "Layer 2s / Rollups" as L2s #LightYellow {
    component "Rollup N" as L2 {
        component "API (e.g. JSON-RPC)" as L2_RPC
        component Executor as L2_Exec
        component Prover as L2_Prover
        database "State DB" as L2_State
    }
}
package "Ethereum Layer 1" as L1 #LightGray {
    package "Espresso Contracts" as Esp_L1 {
        component "Light Client\nContract" as LC_L1
        component "Fee\nContract" as Fee_L1
    }
    package "Rollup Contracts" {
        component "Rollup N\nContract" as L2_L1
    }
}

entity User
User -Up-> L2_RPC : transactions,\nstate queries
' note top of link
' 1. Many clients submit
'     transactions to each
'     L2 simultaneously (for
'     clarity only one is
'     shown)
' end note

L2_RPC --> Submit : "transaction\nNamespaceId Rollup N" " "
/'
 ' note top of link
 ' 2. L2s forward transactions to sequencer.
 ' end note
 '/

Query -up-> L2_Exec : " " "Block\n(sequenced transactions)"
/'
 ' note top of link
 ' 3. Sequencer produces blocks --
 '     ordered lists of transactions.
 '     L2s receive blocks and execute
 '     transactions for their rollup.
 ' end note
 '/

HSProver -down-> LC_L1 : HotShot\nstate\nproof
/'
 ' note right of link
 ' 4. Sequencer posts succinct commitment
 '     to block to L1. Contract verifies proof
 '     of sequencing (Quorum Certificate)
 '     then stores the block commitment.
 ' end note
 '/

L2_Prover -> L2_L1 : rollup\nstate\nproof
/'
 ' note bottom of link
 ' 5. Rollups post
 '     updated state
 '     to L1. ZK-rollups
 '     include a proof.
 ' end note
 '/

LC_L1 -> L2_L1 : HotShot\ncommitment
/'
 ' note bottom of link
 ' 6. Rollup contracts read certified sequence
 '     of block commitments from sequencer
 '     contract. Verify state transition proofs
 '     against this sequence (ZKR) or wait for
 '     fraud proof against this sequence (ORU).
 ' end note
 '/

' L2 1 details
L2_RPC <-up- L2_State : Read state
L2_Exec -up-> L2_State : Write state
L2_Prover <-up- L2_State : Read State

Builder --> Fee_L1: deposit\nfee
Fee_L1 -up-> Validated: fee\ndeposits

@enduml
