//! Solidity types for interacting with contracts
//! Re-export types that are used, sometimes renamed to avoid collision.
//!
//! TODO: (alex) Due to <https://github.com/foundry-rs/foundry/issues/10153>,
//! try to re-export the same type from the "youngest" child contract since that is the contract whose functions are being called,
//! thus from whom the rust bindings are expected.
//! E.g. Both PlonkVerifier and LightClient, and LightClientV2 depends on BN254. The inheritance relationship is:
//!   BN254 <- PlonkVerifier <- LIghtClient <- LightClientV2
//! Most of the time, we interact with PlonkVerifier's function via LightClientV2, thus import BN254.G1Point from `bindings::plonkverifierv2`.
//! When we need to directly interact with PlonkVerifier's method, implement stupid plain `From<lc2::BN254::G1Point> for pv::BN254::G1Point`.
//! If you are lazy, you can even use unsafe memory transmute since they are literally the same representation, duplicated in different modules,
//! thus treated by the rust type systems as distinct types.
//!
//! Another usage is in the differential testing in Solidity tests. In those cases, the actual types don't matter, since they will all `abi_encode()`
//! into the exact same bytes before being communicated over to contract via FFI. Thus using any one of them is fine.

use alloy::sol;

/// # What to re-export, what to hide?
/// - export contract struct itself, but try to avoid export instance type (instead, use ::new() to get a handle)
/// - avoid exporting `xxCall` and `xxReturn` types, they usually can be converted/transmuted from existing struct
/// - Event types should be exported
/// - structs should be exported and renamed with `xxSol` suffix to avoid confusion with other rust types
///   - see module doc for more explanation on types duplication issue in alloy
pub use crate::bindings::{
    erc1967_proxy::ERC1967Proxy,
    esp_token::EspToken,
    esp_token_v2::EspTokenV2,
    fee_contract::FeeContract::{self, Deposit},
    light_client::{
        IPlonkVerifier::{PlonkProof as PlonkProofSol, VerifyingKey as VerifyingKeySol},
        LightClient::{
            self, LightClientErrors, LightClientInstance, LightClientState as LightClientStateSol,
            StakeTableState as StakeTableStateSol,
        },
        BN254::G1Point as G1PointSol,
    },
    light_client_mock::{self, LightClientMock},
    light_client_v2::{self, LightClientV2},
    light_client_v2_mock::{self, LightClientV2Mock},
    light_client_v3::{self, LightClientV3},
    light_client_v3_mock::{self, LightClientV3Mock},
    ops_timelock::OpsTimelock,
    ownable_upgradeable::OwnableUpgradeable,
    plonk_verifier::PlonkVerifier,
    plonk_verifier_v2::PlonkVerifierV2,
    plonk_verifier_v3::PlonkVerifierV3,
    reward_claim::RewardClaim,
    safe_exit_timelock::SafeExitTimelock,
    stake_table::StakeTable,
    stake_table_v2::{
        self, EdOnBN254::EdOnBN254Point as EdOnBN254PointSol, StakeTableV2,
        BN254::G2Point as G2PointSol,
    },
};

// For types that we need to interact with some functions but their bindings are not generated
// we manually declare them there. It's possible that they get included in the future commits,
// at which point, the rust type system will complain and we simply remove the manual declaration
// and re-export the type from bindings instead.
sol! {
    /// types in src/legacy/Transcript.sol
    struct TranscriptDataSol {
        bytes32 state;
        bytes transcript;
    }

    /// types in src/libraries/PlonkVerifierV2.sol
    struct ChallengesSol {
        uint256 alpha;
        uint256 alpha2;
        uint256 alpha3;
        uint256 beta;
        uint256 gamma;
        uint256 zeta;
        uint256 v;
        uint256 u;
    }
}

// Due to <https://github.com/foundry-rs/foundry/issues/10153> the rust bindings contain duplicate types for our solidity types.
// In order to avoid writing a lot of boilerplate code we use transmute to convert between these duplicated types.
// Since all the types we transmute between are generated by foundry from the same underlying solidity type
// we expect that the order of fields and types of fields are always the same.
impl From<LightClient::genesisStateReturn> for LightClientStateSol {
    fn from(v: LightClient::genesisStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<light_client_mock::LightClient::LightClientState> for LightClientStateSol {
    fn from(v: light_client_mock::LightClient::LightClientState) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}
impl From<light_client_mock::LightClientMock::finalizedStateReturn> for LightClientStateSol {
    fn from(v: light_client_mock::LightClientMock::finalizedStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientStateSol> for light_client_mock::LightClient::LightClientState {
    fn from(v: LightClientStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<PlonkProofSol> for light_client_mock::IPlonkVerifier::PlonkProof {
    fn from(v: PlonkProofSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<light_client_mock::LightClientMock::genesisStateReturn> for LightClientStateSol {
    fn from(v: light_client_mock::LightClientMock::genesisStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV2::finalizedStateReturn> for LightClientStateSol {
    fn from(v: LightClientV2::finalizedStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV2::votingStakeTableStateReturn> for StakeTableStateSol {
    fn from(v: LightClientV2::votingStakeTableStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<light_client_v2_mock::LightClient::LightClientState> for LightClientStateSol {
    fn from(v: light_client_v2_mock::LightClient::LightClientState) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}
impl From<LightClientStateSol> for light_client_v2_mock::LightClient::LightClientState {
    fn from(v: LightClientStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}
impl From<LightClientStateSol> for light_client_v2::LightClient::LightClientState {
    fn from(v: LightClientStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<StakeTableStateSol> for light_client_v2::LightClient::StakeTableState {
    fn from(v: StakeTableStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}
impl From<StakeTableStateSol> for light_client_v2_mock::LightClient::StakeTableState {
    fn from(v: StakeTableStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV2Mock::genesisStateReturn> for LightClientStateSol {
    fn from(v: LightClientV2Mock::genesisStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV2Mock::finalizedStateReturn> for LightClientStateSol {
    fn from(v: LightClientV2Mock::finalizedStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<PlonkProofSol> for light_client_v2::IPlonkVerifier::PlonkProof {
    fn from(v: PlonkProofSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV2Mock::votingStakeTableStateReturn> for StakeTableStateSol {
    fn from(v: LightClientV2Mock::votingStakeTableStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<G1PointSol> for stake_table_v2::BN254::G1Point {
    fn from(v: G1PointSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<stake_table_v2::BN254::G1Point> for G1PointSol {
    fn from(v: stake_table_v2::BN254::G1Point) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

// Transmute conversion functions for LightClientV3
impl From<LightClientV3::finalizedStateReturn> for LightClientStateSol {
    fn from(v: LightClientV3::finalizedStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV3::votingStakeTableStateReturn> for StakeTableStateSol {
    fn from(v: LightClientV3::votingStakeTableStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientStateSol> for light_client_v3::LightClient::LightClientState {
    fn from(v: LightClientStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<StakeTableStateSol> for light_client_v3::LightClient::StakeTableState {
    fn from(v: StakeTableStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<PlonkProofSol> for light_client_v3::IPlonkVerifier::PlonkProof {
    fn from(v: PlonkProofSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

// Transmute conversion functions for LightClientV3Mock
impl From<light_client_v3_mock::LightClient::LightClientState> for LightClientStateSol {
    fn from(v: light_client_v3_mock::LightClient::LightClientState) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientStateSol> for light_client_v3_mock::LightClient::LightClientState {
    fn from(v: LightClientStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<StakeTableStateSol> for light_client_v3_mock::LightClient::StakeTableState {
    fn from(v: StakeTableStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV3Mock::genesisStateReturn> for LightClientStateSol {
    fn from(v: LightClientV3Mock::genesisStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV3Mock::finalizedStateReturn> for LightClientStateSol {
    fn from(v: LightClientV3Mock::finalizedStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV3Mock::votingStakeTableStateReturn> for StakeTableStateSol {
    fn from(v: LightClientV3Mock::votingStakeTableStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

use self::StakeTableV2::{
    ConsensusKeysUpdated, ConsensusKeysUpdatedV2, ValidatorRegistered, ValidatorRegisteredV2,
};

impl PartialEq for ValidatorRegistered {
    fn eq(&self, other: &Self) -> bool {
        self.account == other.account
            && self.blsVk == other.blsVk
            && self.schnorrVk == other.schnorrVk
            && self.commission == other.commission
    }
}

impl PartialEq for ValidatorRegisteredV2 {
    fn eq(&self, other: &Self) -> bool {
        self.account == other.account
            && self.blsVK == other.blsVK
            && self.schnorrVK == other.schnorrVK
            && self.commission == other.commission
            && self.blsSig == other.blsSig
            && self.schnorrSig == other.schnorrSig
    }
}

impl PartialEq for ConsensusKeysUpdated {
    fn eq(&self, other: &Self) -> bool {
        self.account == other.account
            && self.blsVK == other.blsVK
            && self.schnorrVK == other.schnorrVK
    }
}

impl PartialEq for ConsensusKeysUpdatedV2 {
    fn eq(&self, other: &Self) -> bool {
        self.account == other.account
            && self.blsVK == other.blsVK
            && self.schnorrVK == other.schnorrVK
            && self.blsSig == other.blsSig
            && self.schnorrSig == other.schnorrSig
    }
}

impl Clone for StakeTableV2::StakeTableV2Events {
    fn clone(&self) -> Self {
        match self {
            Self::ValidatorRegistered(v) => Self::ValidatorRegistered(*v),
            Self::ValidatorRegisteredV2(v) => Self::ValidatorRegisteredV2(v.clone()),
            Self::ValidatorExit(v) => Self::ValidatorExit(*v),
            Self::Delegated(v) => Self::Delegated(*v),
            Self::Undelegated(v) => Self::Undelegated(*v),
            Self::ConsensusKeysUpdated(v) => Self::ConsensusKeysUpdated(*v),
            Self::ConsensusKeysUpdatedV2(v) => Self::ConsensusKeysUpdatedV2(v.clone()),
            Self::CommissionUpdated(v) => Self::CommissionUpdated(v.clone()),
            Self::ExitEscrowPeriodUpdated(v) => Self::ExitEscrowPeriodUpdated(v.clone()),
            Self::MaxCommissionIncreaseUpdated(v) => Self::MaxCommissionIncreaseUpdated(v.clone()),
            Self::MinCommissionUpdateIntervalUpdated(v) => {
                Self::MinCommissionUpdateIntervalUpdated(v.clone())
            },
            Self::OwnershipTransferred(v) => Self::OwnershipTransferred(v.clone()),
            Self::Paused(v) => Self::Paused(v.clone()),
            Self::Unpaused(v) => Self::Unpaused(v.clone()),
            Self::Initialized(v) => Self::Initialized(v.clone()),
            Self::RoleAdminChanged(v) => Self::RoleAdminChanged(v.clone()),
            Self::RoleGranted(v) => Self::RoleGranted(v.clone()),
            Self::RoleRevoked(v) => Self::RoleRevoked(v.clone()),
            Self::Upgraded(v) => Self::Upgraded(v.clone()),
            Self::Withdrawal(v) => Self::Withdrawal(v.clone()),
        }
    }
}

impl std::fmt::Debug for StakeTableV2::StakeTableV2Events {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Self::ValidatorRegistered(_) => write!(f, "ValidatorRegistered(_)"),
            Self::ValidatorRegisteredV2(_) => write!(f, "ValidatorRegisteredV2(_)"),
            Self::ValidatorExit(v) => write!(f, "ValidatorExit({v:?})"),
            Self::Delegated(v) => write!(f, "Delegated({v:?})"),
            Self::Undelegated(v) => write!(f, "Undelegated({v:?})"),
            Self::ConsensusKeysUpdated(_) => write!(f, "ConsensusKeysUpdated(_)"),
            Self::ConsensusKeysUpdatedV2(_) => write!(f, "ConsensusKeysUpdatedV2(_)"),
            Self::CommissionUpdated(v) => write!(f, "CommissionUpdated({v:?})"),
            Self::ExitEscrowPeriodUpdated(v) => write!(f, "ExitEscrowPeriodUpdated({v:?})"),
            Self::MaxCommissionIncreaseUpdated(v) => {
                write!(f, "MaxCommissionIncreaseUpdated({v:?})")
            },
            Self::MinCommissionUpdateIntervalUpdated(v) => {
                write!(f, "MinCommissionUpdateIntervalUpdated({v:?})")
            },
            Self::OwnershipTransferred(v) => write!(f, "OwnershipTransferred({v:?})"),
            Self::Paused(v) => write!(f, "Paused({v:?})"),
            Self::Unpaused(v) => write!(f, "Unpaused({v:?})"),
            Self::Initialized(v) => write!(f, "Initialized({v:?})"),
            Self::RoleAdminChanged(v) => write!(f, "RoleAdminChanged({v:?})"),
            Self::RoleGranted(v) => write!(f, "RoleGranted({v:?})"),
            Self::RoleRevoked(v) => write!(f, "RoleRevoked({v:?})"),
            Self::Upgraded(v) => write!(f, "Upgraded({v:?})"),
            Self::Withdrawal(v) => write!(f, "Withdrawal({v:?})"),
        }
    }
}
#[cfg(test)]
mod tests {
    use alloy::{primitives::U256, sol_types::private::Address};

    use crate::sol_types::StakeTableV2::CommissionUpdated;

    #[test]
    fn test_commission_updated_serde_roundtrip() {
        let original = CommissionUpdated {
            validator: Address::random(),
            timestamp: U256::from(999),
            oldCommission: 123,
            newCommission: 456,
        };

        let serialized = bincode::serialize(&original).expect("Failed to serialize");
        let deserialized: CommissionUpdated =
            bincode::deserialize(&serialized).expect("Failed to deserialize");

        assert_eq!(original.validator, deserialized.validator);
        assert_eq!(original.timestamp, deserialized.timestamp);
        assert_eq!(original.oldCommission, deserialized.oldCommission);
        assert_eq!(original.newCommission, deserialized.newCommission);
    }
}
