//! Solidity types for interacting with contracts
//! Re-export types that are used, sometimes renamed to avoid collision.
//!
//! TODO: (alex) Due to <https://github.com/foundry-rs/foundry/issues/10153>,
//! try to re-export the same type from the "youngest" child contract since that is the contract whose functions are being called,
//! thus from whom the rust bindings are expected.
//! E.g. Both PlonkVerifier and LightClient, and LightClientV2 depends on BN254. The inheritance relationship is:
//!   BN254 <- PlonkVerifier <- LIghtClient <- LightClientV2
//! Most of the time, we interact with PlonkVerifier's function via LightClientV2, thus import BN254.G1Point from `bindings::plonkverifierv2`.
//! When we need to directly interact with PlonkVerifier's method, implement stupid plain `From<lc2::BN254::G1Point> for pv::BN254::G1Point`.
//! If you are lazy, you can even use unsafe memory transmute since they are literally the same representation, duplicated in different modules,
//! thus treated by the rust type systems as distinct types.
//!
//! Another usage is in the differential testing in Solidity tests. In those cases, the actual types don't matter, since they will all `abi_encode()`
//! into the exact same bytes before being communicated over to contract via FFI. Thus using any one of them is fine.

use alloy::sol;

use crate::bindings::stake_table_v2::{
    EdOnBN254,
    BN254::{self, BaseField},
};
/// # What to re-export, what to hide?
/// - export contract struct itself, but try to avoid export instance type (instead, use ::new() to get a handle)
/// - avoid exporting `xxCall` and `xxReturn` types, they usually can be converted/transmuted from existing struct
/// - Event types should be exported
/// - structs should be exported and renamed with `xxSol` suffix to avoid confusion with other rust types
///   - see module doc for more explanation on types duplication issue in alloy
pub use crate::bindings::{
    erc1967_proxy::ERC1967Proxy,
    esp_token::EspToken,
    esp_token_v2::EspTokenV2,
    fee_contract::FeeContract::{self, Deposit},
    light_client::{
        IPlonkVerifier::{PlonkProof as PlonkProofSol, VerifyingKey as VerifyingKeySol},
        LightClient::{
            self, LightClientErrors, LightClientInstance, LightClientState as LightClientStateSol,
            StakeTableState as StakeTableStateSol,
        },
        BN254::G1Point as G1PointSol,
    },
    light_client_mock::{self, LightClientMock},
    light_client_v2::{self, LightClientV2},
    light_client_v2_mock::{self, LightClientV2Mock},
    light_client_v3::{self, LightClientV3},
    light_client_v3_mock::{self, LightClientV3Mock},
    ops_timelock::OpsTimelock,
    ownable_upgradeable::OwnableUpgradeable,
    plonk_verifier::PlonkVerifier,
    plonk_verifier_v2::PlonkVerifierV2,
    plonk_verifier_v3::PlonkVerifierV3,
    reward_claim_prototype_mock::{
        RewardClaimPrototypeMock,
        RewardMerkleTreeVerifier::AccruedRewardsProof as AccruedRewardsProofSol,
    },
    safe_exit_timelock::SafeExitTimelock,
    stake_table::StakeTable,
    stake_table_v2::{
        self, EdOnBN254::EdOnBN254Point as EdOnBN254PointSol, StakeTableV2,
        BN254::G2Point as G2PointSol,
    },
};

// For types that we need to interact with some functions but their bindings are not generated
// we manually declare them there. It's possible that they get included in the future commits,
// at which point, the rust type system will complain and we simply remove the manual declaration
// and re-export the type from bindings instead.
sol! {
    /// types in src/legacy/Transcript.sol
    struct TranscriptDataSol {
        bytes32 state;
        bytes transcript;
    }

    /// types in src/libraries/PlonkVerifierV2.sol
    struct ChallengesSol {
        uint256 alpha;
        uint256 alpha2;
        uint256 alpha3;
        uint256 beta;
        uint256 gamma;
        uint256 zeta;
        uint256 v;
        uint256 u;
    }

}

// Due to <https://github.com/foundry-rs/foundry/issues/10153> the rust bindings contain duplicate types for our solidity types.
// In order to avoid writing a lot of boilerplate code we use transmute to convert between these duplicated types.
// Since all the types we transmute between are generated by foundry from the same underlying solidity type
// we expect that the order of fields and types of fields are always the same.
impl From<LightClient::genesisStateReturn> for LightClientStateSol {
    fn from(v: LightClient::genesisStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<light_client_mock::LightClient::LightClientState> for LightClientStateSol {
    fn from(v: light_client_mock::LightClient::LightClientState) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}
impl From<light_client_mock::LightClientMock::finalizedStateReturn> for LightClientStateSol {
    fn from(v: light_client_mock::LightClientMock::finalizedStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientStateSol> for light_client_mock::LightClient::LightClientState {
    fn from(v: LightClientStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<PlonkProofSol> for light_client_mock::IPlonkVerifier::PlonkProof {
    fn from(v: PlonkProofSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<light_client_mock::LightClientMock::genesisStateReturn> for LightClientStateSol {
    fn from(v: light_client_mock::LightClientMock::genesisStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV2::finalizedStateReturn> for LightClientStateSol {
    fn from(v: LightClientV2::finalizedStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV2::votingStakeTableStateReturn> for StakeTableStateSol {
    fn from(v: LightClientV2::votingStakeTableStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<light_client_v2_mock::LightClient::LightClientState> for LightClientStateSol {
    fn from(v: light_client_v2_mock::LightClient::LightClientState) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}
impl From<LightClientStateSol> for light_client_v2_mock::LightClient::LightClientState {
    fn from(v: LightClientStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}
impl From<LightClientStateSol> for light_client_v2::LightClient::LightClientState {
    fn from(v: LightClientStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<StakeTableStateSol> for light_client_v2::LightClient::StakeTableState {
    fn from(v: StakeTableStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}
impl From<StakeTableStateSol> for light_client_v2_mock::LightClient::StakeTableState {
    fn from(v: StakeTableStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV2Mock::genesisStateReturn> for LightClientStateSol {
    fn from(v: LightClientV2Mock::genesisStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV2Mock::finalizedStateReturn> for LightClientStateSol {
    fn from(v: LightClientV2Mock::finalizedStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<PlonkProofSol> for light_client_v2::IPlonkVerifier::PlonkProof {
    fn from(v: PlonkProofSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV2Mock::votingStakeTableStateReturn> for StakeTableStateSol {
    fn from(v: LightClientV2Mock::votingStakeTableStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<G1PointSol> for stake_table_v2::BN254::G1Point {
    fn from(v: G1PointSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<stake_table_v2::BN254::G1Point> for G1PointSol {
    fn from(v: stake_table_v2::BN254::G1Point) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

// Transmute conversion functions for LightClientV3
impl From<LightClientV3::finalizedStateReturn> for LightClientStateSol {
    fn from(v: LightClientV3::finalizedStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV3::votingStakeTableStateReturn> for StakeTableStateSol {
    fn from(v: LightClientV3::votingStakeTableStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientStateSol> for light_client_v3::LightClient::LightClientState {
    fn from(v: LightClientStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<StakeTableStateSol> for light_client_v3::LightClient::StakeTableState {
    fn from(v: StakeTableStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<PlonkProofSol> for light_client_v3::IPlonkVerifier::PlonkProof {
    fn from(v: PlonkProofSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

// Transmute conversion functions for LightClientV3Mock
impl From<light_client_v3_mock::LightClient::LightClientState> for LightClientStateSol {
    fn from(v: light_client_v3_mock::LightClient::LightClientState) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientStateSol> for light_client_v3_mock::LightClient::LightClientState {
    fn from(v: LightClientStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<StakeTableStateSol> for light_client_v3_mock::LightClient::StakeTableState {
    fn from(v: StakeTableStateSol) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV3Mock::genesisStateReturn> for LightClientStateSol {
    fn from(v: LightClientV3Mock::genesisStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV3Mock::finalizedStateReturn> for LightClientStateSol {
    fn from(v: LightClientV3Mock::finalizedStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

impl From<LightClientV3Mock::votingStakeTableStateReturn> for StakeTableStateSol {
    fn from(v: LightClientV3Mock::votingStakeTableStateReturn) -> Self {
        unsafe { std::mem::transmute(v) }
    }
}

use serde::{Deserialize, Deserializer, Serialize, Serializer};

use self::StakeTableV2::{
    ConsensusKeysUpdated, ConsensusKeysUpdatedV2, Delegated, Undelegated, ValidatorExit,
    ValidatorRegistered, ValidatorRegisteredV2,
};

impl PartialEq for ValidatorRegistered {
    fn eq(&self, other: &Self) -> bool {
        self.account == other.account
            && self.blsVk == other.blsVk
            && self.schnorrVk == other.schnorrVk
            && self.commission == other.commission
    }
}

impl PartialEq for ValidatorRegisteredV2 {
    fn eq(&self, other: &Self) -> bool {
        self.account == other.account
            && self.blsVK == other.blsVK
            && self.schnorrVK == other.schnorrVK
            && self.commission == other.commission
            && self.blsSig == other.blsSig
            && self.schnorrSig == other.schnorrSig
    }
}

impl PartialEq for ConsensusKeysUpdated {
    fn eq(&self, other: &Self) -> bool {
        self.account == other.account
            && self.blsVK == other.blsVK
            && self.schnorrVK == other.schnorrVK
    }
}

impl PartialEq for ConsensusKeysUpdatedV2 {
    fn eq(&self, other: &Self) -> bool {
        self.account == other.account
            && self.blsVK == other.blsVK
            && self.schnorrVK == other.schnorrVK
            && self.blsSig == other.blsSig
            && self.schnorrSig == other.schnorrSig
    }
}

#[derive()]
/**Event with signature `ValidatorRegistered(address,(uint256,uint256,uint256,uint256),(uint256,uint256),uint16)` and selector `0xf6e8359c57520b469634736bfc3bb7ec5cbd1a0bd28b10a8275793bb730b797f`.
```solidity
event ValidatorRegistered(address indexed account, BN254.G2Point blsVk, EdOnBN254.EdOnBN254Point schnorrVk, uint16 commission);
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
#[derive(Clone)]
pub struct ValidatorRegisteredLegacy {
    #[allow(missing_docs)]
    pub account: alloy::sol_types::private::Address,
    #[allow(missing_docs)]
    pub blsVk: G2PointLegacy,
    #[allow(missing_docs)]
    pub schnorrVk: EdOnBN254PointLegacy,
    #[allow(missing_docs)]
    pub commission: u16,
}

impl Serialize for ValidatorRegisteredLegacy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (&self.account, &self.blsVk, &self.schnorrVk, self.commission).serialize(serializer)
    }
}

#[allow(non_snake_case)]
impl<'de> Deserialize<'de> for ValidatorRegisteredLegacy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (account, blsVk, schnorrVk, commission) = <(_, _, _, u16)>::deserialize(deserializer)?;
        Ok(Self {
            account,
            blsVk,
            schnorrVk,
            commission,
        })
    }
}

#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
#[derive(Clone)]
pub struct ValidatorRegisteredV2Legacy {
    #[allow(missing_docs)]
    pub account: alloy::sol_types::private::Address,
    #[allow(missing_docs)]
    pub blsVK: G2PointLegacy,
    #[allow(missing_docs)]
    pub schnorrVK: EdOnBN254PointLegacy,
    #[allow(missing_docs)]
    pub commission: u16,
    #[allow(missing_docs)]
    pub blsSig: G1PointLegacy,
    #[allow(missing_docs)]
    pub schnorrSig: alloy::sol_types::private::Bytes,
}

impl Serialize for ValidatorRegisteredV2Legacy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (
            &self.account,
            &self.blsVK,
            &self.schnorrVK,
            self.commission,
            &self.blsSig,
            &self.schnorrSig,
        )
            .serialize(serializer)
    }
}

#[allow(non_snake_case)]
impl<'de> Deserialize<'de> for ValidatorRegisteredV2Legacy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (account, blsVK, schnorrVK, commission, blsSig, schnorrSig) =
            <(_, _, _, u16, _, _)>::deserialize(deserializer)?;
        Ok(Self {
            account,
            blsVK,
            schnorrVK,
            commission,
            blsSig,
            schnorrSig,
        })
    }
}

#[derive(Default, Debug, PartialEq, Eq, Hash)]
/**```solidity
struct EdOnBN254Point { uint256 x; uint256 y; }
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
#[derive(Clone)]
pub struct EdOnBN254PointLegacy {
    #[allow(missing_docs)]
    pub x: alloy::sol_types::private::primitives::aliases::U256,
    #[allow(missing_docs)]
    pub y: alloy::sol_types::private::primitives::aliases::U256,
}

impl Serialize for EdOnBN254PointLegacy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (self.x, self.y).serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for EdOnBN254PointLegacy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (x, y) = Deserialize::deserialize(deserializer)?;
        Ok(Self { x, y })
    }
}

#[derive(Default, Debug, PartialEq, Eq, Hash)]
/**```solidity
struct G2Point { BaseField x0; BaseField x1; BaseField y0; BaseField y1; }
```*/
#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
#[derive(Clone)]
pub struct G2PointLegacy {
    #[allow(missing_docs)]
    pub x0: <BaseField as alloy::sol_types::SolType>::RustType,
    #[allow(missing_docs)]
    pub x1: <BaseField as alloy::sol_types::SolType>::RustType,
    #[allow(missing_docs)]
    pub y0: <BaseField as alloy::sol_types::SolType>::RustType,
    #[allow(missing_docs)]
    pub y1: <BaseField as alloy::sol_types::SolType>::RustType,
}

impl Serialize for G2PointLegacy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (&self.x0, &self.x1, &self.y0, &self.y1).serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for G2PointLegacy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (x0, x1, y0, y1) = Deserialize::deserialize(deserializer)?;

        Ok(Self { x0, x1, y0, y1 })
    }
}

#[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
#[derive(Clone)]
pub struct G1PointLegacy {
    #[allow(missing_docs)]
    pub x: <BaseField as alloy::sol_types::SolType>::RustType,
    #[allow(missing_docs)]
    pub y: <BaseField as alloy::sol_types::SolType>::RustType,
}

impl Serialize for G1PointLegacy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (&self.x, &self.y).serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for G1PointLegacy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (x, y) = Deserialize::deserialize(deserializer)?;
        Ok(Self { x, y })
    }
}

#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
#[derive(Clone)]
pub struct ValidatorExitLegacy {
    #[allow(missing_docs)]
    pub validator: alloy::sol_types::private::Address,
}

impl Serialize for ValidatorExitLegacy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (&self.validator,).serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for ValidatorExitLegacy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (validator,): (alloy::sol_types::private::Address,) =
            Deserialize::deserialize(deserializer)?;
        Ok(Self { validator })
    }
}

#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
#[derive(Clone)]
pub struct DelegatedLegacy {
    #[allow(missing_docs)]
    pub delegator: alloy::sol_types::private::Address,
    #[allow(missing_docs)]
    pub validator: alloy::sol_types::private::Address,
    #[allow(missing_docs)]
    pub amount: alloy::sol_types::private::primitives::aliases::U256,
}

impl Serialize for DelegatedLegacy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (&self.delegator, &self.validator, &self.amount).serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for DelegatedLegacy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (delegator, validator, amount) = Deserialize::deserialize(deserializer)?;

        Ok(Self {
            delegator,
            validator,
            amount,
        })
    }
}

#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
#[derive(Clone)]
pub struct UndelegatedLegacy {
    #[allow(missing_docs)]
    pub delegator: alloy::sol_types::private::Address,
    #[allow(missing_docs)]
    pub validator: alloy::sol_types::private::Address,
    #[allow(missing_docs)]
    pub amount: alloy::sol_types::private::primitives::aliases::U256,
}

impl Serialize for UndelegatedLegacy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (&self.delegator, &self.validator, &self.amount).serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for UndelegatedLegacy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (delegator, validator, amount) = Deserialize::deserialize(deserializer)?;

        Ok(Self {
            delegator,
            validator,
            amount,
        })
    }
}

#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
#[derive(Clone)]
pub struct ConsensusKeysUpdatedLegacy {
    #[allow(missing_docs)]
    pub account: alloy::sol_types::private::Address,
    #[allow(missing_docs)]
    pub blsVK: G2PointLegacy,
    #[allow(missing_docs)]
    pub schnorrVK: EdOnBN254PointLegacy,
}

impl Serialize for ConsensusKeysUpdatedLegacy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (&self.account, &self.blsVK, &self.schnorrVK).serialize(serializer)
    }
}

#[allow(non_snake_case)]
impl<'de> Deserialize<'de> for ConsensusKeysUpdatedLegacy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (account, blsVK, schnorrVK) = Deserialize::deserialize(deserializer)?;

        Ok(Self {
            account,
            blsVK,
            schnorrVK,
        })
    }
}

#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
#[derive(Clone)]
pub struct ConsensusKeysUpdatedV2Legacy {
    #[allow(missing_docs)]
    pub account: alloy::sol_types::private::Address,
    #[allow(missing_docs)]
    pub blsVK: G2PointLegacy,
    #[allow(missing_docs)]
    pub schnorrVK: EdOnBN254PointLegacy,
    #[allow(missing_docs)]
    pub blsSig: G1PointLegacy,
    #[allow(missing_docs)]
    pub schnorrSig: alloy::sol_types::private::Bytes,
}

impl Serialize for ConsensusKeysUpdatedV2Legacy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        (
            &self.account,
            &self.blsVK,
            &self.schnorrVK,
            &self.blsSig,
            &self.schnorrSig,
        )
            .serialize(serializer)
    }
}

#[allow(non_snake_case)]
impl<'de> Deserialize<'de> for ConsensusKeysUpdatedV2Legacy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let (account, blsVK, schnorrVK, blsSig, schnorrSig) =
            Deserialize::deserialize(deserializer)?;
        Ok(Self {
            account,
            blsVK,
            schnorrVK,
            blsSig,
            schnorrSig,
        })
    }
}

impl From<ValidatorRegisteredLegacy> for ValidatorRegistered {
    fn from(v: ValidatorRegisteredLegacy) -> Self {
        Self {
            account: v.account,
            blsVk: v.blsVk.into(),
            schnorrVk: v.schnorrVk.into(),
            commission: v.commission,
        }
    }
}

impl From<ValidatorRegisteredV2Legacy> for ValidatorRegisteredV2 {
    fn from(v: ValidatorRegisteredV2Legacy) -> Self {
        Self {
            account: v.account,
            blsVK: v.blsVK.into(),
            schnorrVK: v.schnorrVK.into(),
            commission: v.commission,
            blsSig: v.blsSig.into(),
            schnorrSig: v.schnorrSig,
        }
    }
}

impl From<ValidatorExitLegacy> for ValidatorExit {
    fn from(v: ValidatorExitLegacy) -> Self {
        Self {
            validator: v.validator,
        }
    }
}

impl From<DelegatedLegacy> for Delegated {
    fn from(v: DelegatedLegacy) -> Self {
        Self {
            delegator: v.delegator,
            validator: v.validator,
            amount: v.amount,
        }
    }
}

impl From<UndelegatedLegacy> for Undelegated {
    fn from(v: UndelegatedLegacy) -> Self {
        Self {
            delegator: v.delegator,
            validator: v.validator,
            amount: v.amount,
        }
    }
}

impl From<ConsensusKeysUpdatedLegacy> for ConsensusKeysUpdated {
    fn from(v: ConsensusKeysUpdatedLegacy) -> Self {
        Self {
            account: v.account,
            blsVK: v.blsVK.into(),
            schnorrVK: v.schnorrVK.into(),
        }
    }
}

impl From<ConsensusKeysUpdatedV2Legacy> for ConsensusKeysUpdatedV2 {
    fn from(v: ConsensusKeysUpdatedV2Legacy) -> Self {
        Self {
            account: v.account,
            blsVK: v.blsVK.into(),
            schnorrVK: v.schnorrVK.into(),
            blsSig: v.blsSig.into(),
            schnorrSig: v.schnorrSig,
        }
    }
}

impl From<G2PointLegacy> for BN254::G2Point {
    fn from(v: G2PointLegacy) -> Self {
        Self {
            x0: v.x0,
            x1: v.x1,
            y0: v.y0,
            y1: v.y1,
        }
    }
}

impl From<G1PointLegacy> for BN254::G1Point {
    fn from(v: G1PointLegacy) -> Self {
        Self { x: v.x, y: v.y }
    }
}

impl From<EdOnBN254PointLegacy> for EdOnBN254::EdOnBN254Point {
    fn from(v: EdOnBN254PointLegacy) -> Self {
        Self { x: v.x, y: v.y }
    }
}

impl From<ValidatorRegistered> for ValidatorRegisteredLegacy {
    fn from(v: ValidatorRegistered) -> Self {
        Self {
            account: v.account,
            blsVk: v.blsVk.into(),
            schnorrVk: v.schnorrVk.into(),
            commission: v.commission,
        }
    }
}

impl From<ValidatorRegisteredV2> for ValidatorRegisteredV2Legacy {
    fn from(v: ValidatorRegisteredV2) -> Self {
        Self {
            account: v.account,
            blsVK: v.blsVK.into(),
            schnorrVK: v.schnorrVK.into(),
            commission: v.commission,
            blsSig: v.blsSig.into(),
            schnorrSig: v.schnorrSig,
        }
    }
}

impl From<ValidatorExit> for ValidatorExitLegacy {
    fn from(v: ValidatorExit) -> Self {
        Self {
            validator: v.validator,
        }
    }
}

impl From<Delegated> for DelegatedLegacy {
    fn from(v: Delegated) -> Self {
        Self {
            delegator: v.delegator,
            validator: v.validator,
            amount: v.amount,
        }
    }
}

impl From<Undelegated> for UndelegatedLegacy {
    fn from(v: Undelegated) -> Self {
        Self {
            delegator: v.delegator,
            validator: v.validator,
            amount: v.amount,
        }
    }
}

impl From<ConsensusKeysUpdated> for ConsensusKeysUpdatedLegacy {
    fn from(v: ConsensusKeysUpdated) -> Self {
        Self {
            account: v.account,
            blsVK: v.blsVK.into(),
            schnorrVK: v.schnorrVK.into(),
        }
    }
}

impl From<ConsensusKeysUpdatedV2> for ConsensusKeysUpdatedV2Legacy {
    fn from(v: ConsensusKeysUpdatedV2) -> Self {
        Self {
            account: v.account,
            blsVK: v.blsVK.into(),
            schnorrVK: v.schnorrVK.into(),
            blsSig: v.blsSig.into(),
            schnorrSig: v.schnorrSig,
        }
    }
}

impl From<BN254::G2Point> for G2PointLegacy {
    fn from(v: BN254::G2Point) -> Self {
        Self {
            x0: v.x0,
            x1: v.x1,
            y0: v.y0,
            y1: v.y1,
        }
    }
}

impl From<G1PointSol> for G1PointLegacy {
    fn from(v: G1PointSol) -> Self {
        Self { x: v.x, y: v.y }
    }
}

impl From<BN254::G1Point> for G1PointLegacy {
    fn from(v: BN254::G1Point) -> Self {
        Self { x: v.x, y: v.y }
    }
}

impl From<EdOnBN254::EdOnBN254Point> for EdOnBN254PointLegacy {
    fn from(v: EdOnBN254::EdOnBN254Point) -> Self {
        Self { x: v.x, y: v.y }
    }
}

#[cfg(test)]
mod tests {
    use alloy::{primitives::U256, sol_types::private::Address};

    use crate::sol_types::StakeTableV2::CommissionUpdated;

    #[test]
    fn test_commission_updated_serde_roundtrip() {
        let original = CommissionUpdated {
            validator: Address::random(),
            timestamp: U256::from(999),
            oldCommission: 123,
            newCommission: 456,
        };

        let serialized = bincode::serialize(&original).expect("Failed to serialize");
        let deserialized: CommissionUpdated =
            bincode::deserialize(&serialized).expect("Failed to deserialize");

        assert_eq!(original.validator, deserialized.validator);
        assert_eq!(original.timestamp, deserialized.timestamp);
        assert_eq!(original.oldCommission, deserialized.oldCommission);
        assert_eq!(original.newCommission, deserialized.newCommission);
    }
}
