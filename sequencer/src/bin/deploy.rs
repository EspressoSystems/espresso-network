use std::{fs::File, io::stdout, path::PathBuf, thread::sleep, time::Duration};

use alloy::{
    primitives::{utils::format_ether, Address, U256},
    providers::{Provider, WalletProvider},
};
use anyhow::Context as _;
use clap::{Parser, Subcommand};
use espresso_contract_deployer::{
    build_provider, build_provider_ledger,
    builder::DeployerArgsBuilder,
    network_config::{light_client_genesis, light_client_genesis_from_stake_table},
    provider::connect_ledger,
    verify_node_js_files, Contract, Contracts, DeployedContracts,
};
use espresso_types::{config::PublicNetworkConfig, parse_duration};
use hotshot_types::light_client::DEFAULT_STAKE_TABLE_CAPACITY;
use sequencer_utils::logging;
use tide_disco::error::ServerError;
use url::Url;
use vbs::version::StaticVersion;

/// Deploy contracts needed to run the sequencer.
///
/// This script deploys contracts needed to run the sequencer to an L1. It outputs a .env file
/// containing the addresses of the deployed contracts.
///
/// This script can also be used to do incremental deployments. The only contract addresses
/// needed to configure the sequencer network are ESPRESSO_SEQUENCER_FEE_CONTRACT_PROXY_ADDRESS,
/// ESPRESSO_SEQUENCER_LIGHT_CLIENT_PROXY_ADDRESS and ESPRESSO_SEQUENCER_STAKE_TABLE_ADDRESS.
/// These contracts, however, have dependencies, and a full deployment involves several
/// contracts. Some of these contracts, especially libraries may already have been deployed, or
/// perhaps one of the top-level contracts has been deployed and we only need to deploy the other
/// one.
///
/// It is possible to pass in the addresses of already deployed contracts, in which case those
/// addresses will be used in place of deploying a new contract wherever that contract is required
/// in the deployment process. The generated .env file will include all the addresses passed in as
/// well as those newly deployed.
#[derive(Clone, Debug, Parser)]
struct Options {
    /// A JSON-RPC endpoint for the L1 to deploy to.
    #[clap(
        short,
        long,
        env = "ESPRESSO_SEQUENCER_L1_PROVIDER",
        default_value = "http://localhost:8545"
    )]
    rpc_url: Url,

    /// Request rate when polling L1.
    #[clap(
        long,
        env = "ESPRESSO_SEQUENCER_L1_POLLING_INTERVAL",
        default_value = "7s",
        value_parser = parse_duration,
    )]
    pub l1_polling_interval: Duration,

    /// URL of a sequencer node that is currently providing the HotShot config.
    /// This is used to initialize the stake table.
    #[clap(
        long,
        env = "ESPRESSO_SEQUENCER_URL",
        default_value = "http://localhost:24000"
    )]
    pub sequencer_url: Url,

    /// Mnemonic for an L1 wallet.
    ///
    /// This wallet is used to deploy the contracts, so the account indicated by ACCOUNT_INDEX must
    /// be funded with with ETH.
    #[clap(
        long,
        name = "MNEMONIC",
        env = "ESPRESSO_SEQUENCER_ETH_MNEMONIC",
        default_value = "test test test test test test test test test test test junk",
        conflicts_with = "LEDGER"
    )]
    mnemonic: Option<String>,

    /// Address for the multisig wallet that will be the admin
    ///
    /// If provided, this the multisig wallet that will be able to upgrade contracts and execute
    /// admin only functions on contracts. If not provided, admin power for all contracts will be
    /// held by the account used to deploy the contracts (determined from MNEMONIC, ACCOUNT_INDEX).
    #[clap(
        long,
        name = "MULTISIG_ADDRESS",
        env = "ESPRESSO_SEQUENCER_ETH_MULTISIG_ADDRESS"
    )]
    multisig_address: Option<Address>,

    /// Address for the multisig wallet that will be the pauser
    ///
    /// The multisig pauser can pause functions in contracts that have the `whenNotPaused` modifier
    #[clap(
        long,
        name = "MULTISIG_PAUSER_ADDRESS",
        env = "ESPRESSO_SEQUENCER_ETH_MULTISIG_PAUSER_ADDRESS"
    )]
    multisig_pauser_address: Option<Address>,

    /// Account index in the L1 wallet generated by MNEMONIC to use when deploying the contracts.
    #[clap(
        long,
        name = "ACCOUNT_INDEX",
        env = "ESPRESSO_DEPLOYER_ACCOUNT_INDEX",
        default_value = "0"
    )]
    account_index: u32,

    /// Use a ledger device to sign transactions.
    ///
    /// NOTE: ledger must be unlocked, Ethereum app open and blind signing must be enabled in the
    /// Ethereum app settings.
    #[clap(
        long,
        name = "LEDGER",
        env = "ESPRESSO_DEPLOYER_USE_LEDGER",
        conflicts_with = "MNEMONIC"
    )]
    ledger: bool,

    /// Option to deploy fee contracts
    #[clap(long, default_value = "false")]
    deploy_fee: bool,
    /// Option to deploy LightClient V1 and proxy
    #[clap(long, default_value = "false")]
    deploy_light_client_v1: bool,
    /// Option to upgrade to LightClient V2
    #[clap(long, default_value = "false")]
    upgrade_light_client_v2: bool,
    /// Option to deploy esp token
    #[clap(long, default_value = "false")]
    deploy_esp_token: bool,
    /// Option to deploy StakeTable V1 and proxy
    #[clap(long, default_value = "false")]
    deploy_stake_table: bool,
    /// Option to upgrade to StakeTable V2
    #[clap(long, default_value = "false")]
    upgrade_stake_table_v2: bool,
    /// Option to deploy timelock
    #[clap(long, default_value = "false")]
    deploy_timelock: bool,
    /// Option to deploy token timelock
    #[clap(long, default_value = "false")]
    deploy_safe_exit_timelock: bool,

    /// Write deployment results to OUT as a .env file.
    ///
    /// If not provided, the results will be written to stdout.
    #[clap(short, long, name = "OUT", env = "ESPRESSO_DEPLOYER_OUT_PATH")]
    out: Option<PathBuf>,

    #[clap(flatten)]
    contracts: DeployedContracts,

    /// If toggled, launch a mock LightClient contract with a smaller verification key for testing.
    /// Applies to both V1 and V2 of LightClient.
    #[clap(short, long)]
    pub use_mock: bool,

    /// Option to deploy contracts owned by multisig
    #[clap(long, default_value = "false")]
    pub use_multisig: bool,

    /// Option to test upgrade stake table v2 multisig owner dry run
    #[clap(long, default_value = "false")]
    pub dry_run: bool,

    /// Option to test locally but with a real eth network
    #[clap(long, default_value = "false")]
    pub mock_espresso_live_network: bool,

    /// Option to verify node js files access to upgrade stake table v2 multisig owner dry run
    #[clap(long, default_value = "false")]
    pub verify_node_js_files: bool,

    /// Stake table capacity for the prover circuit
    #[clap(short, long, env = "ESPRESSO_SEQUENCER_STAKE_TABLE_CAPACITY", default_value_t = DEFAULT_STAKE_TABLE_CAPACITY)]
    pub stake_table_capacity: usize,
    ///
    /// If the light client contract is being deployed and this is set, the prover will be
    /// permissioned so that only this address can update the light client state. Otherwise, proving
    /// will be permissionless.
    ///
    /// If the light client contract is not being deployed, this option is ignored.
    #[clap(long, env = "ESPRESSO_SEQUENCER_PERMISSIONED_PROVER")]
    permissioned_prover: Option<Address>,

    /// Exit escrow period for the stake table contract.
    ///
    /// This is the period for which stake table contract will retain funds after withdrawals have
    /// been requested. It should be set to a value that is at least 3 hotshot epochs plus ample
    /// time to allow for submission of slashing evidence. Initially it will probably be around one
    /// week.
    #[clap(long, env = "ESPRESSO_SEQUENCER_STAKE_TABLE_EXIT_ESCROW_PERIOD", value_parser = parse_duration)]
    exit_escrow_period: Option<Duration>,

    /// The address that the tokens will be minted to.
    ///
    /// If unset the tokens will be minted to the deployer account.
    #[clap(long, env = "ESP_TOKEN_INITIAL_GRANT_RECIPIENT_ADDRESS")]
    initial_token_grant_recipient: Option<Address>,

    /// The blocks per epoch    
    #[clap(long, env = "ESPRESSO_SEQUENCER_BLOCKS_PER_EPOCH")]
    blocks_per_epoch: Option<u64>,

    /// The epoch start block
    #[clap(long, env = "ESPRESSO_SEQUENCER_EPOCH_START_BLOCK")]
    epoch_start_block: Option<u64>,
    /// The initial supply of the tokens.
    #[clap(long, env = "ESP_TOKEN_INITIAL_SUPPLY", default_value_t = U256::from(3590000000u64))]
    initial_token_supply: U256,

    /// The name of the tokens.
    #[clap(long, env = "ESP_TOKEN_NAME", default_value = "Espresso")]
    token_name: String,

    /// The symbol of the tokens.
    #[clap(long, env = "ESP_TOKEN_SYMBOL", default_value = "ESP")]
    token_symbol: String,

    /// The admin of the timelock
    #[clap(long, env = "ESPRESSO_TIMELOCK_ADMIN")]
    timelock_admin: Option<Address>,

    /// The delay of the timelock
    #[clap(long, env = "ESPRESSO_TIMELOCK_DELAY")]
    timelock_delay: Option<u64>,

    /// The executor(s) of the timelock
    #[clap(long, env = "ESPRESSO_TIMELOCK_EXECUTORS")]
    timelock_executors: Option<Vec<Address>>,

    /// The proposer(s) of the timelock
    #[clap(long, env = "ESPRESSO_TIMELOCK_PROPOSERS")]
    timelock_proposers: Option<Vec<Address>>,

    /// The admin of the token timelock
    #[clap(long, env = "ESPRESSO_SAFE_EXIT_TIMELOCK_ADMIN")]
    safe_exit_timelock_admin: Option<Address>,

    /// The delay of the token timelock
    #[clap(long, env = "ESPRESSO_SAFE_EXIT_TIMELOCK_DELAY")]
    safe_exit_timelock_delay: Option<u64>,

    /// The executor(s) of the token  timelock
    #[clap(long, env = "ESPRESSO_SAFE_EXIT_TIMELOCK_EXECUTORS")]
    safe_exit_timelock_executors: Option<Vec<Address>>,

    /// The proposer(s) of the token timelock
    #[clap(long, env = "ESPRESSO_SAFE_EXIT_TIMELOCK_PROPOSERS")]
    safe_exit_timelock_proposers: Option<Vec<Address>>,

    #[clap(flatten)]
    logging: logging::Config,

    /// Command to run
    ///
    /// For backwards compatibility, the default is to deploy contracts, if no
    /// subcommand is specified.
    #[clap(subcommand)]
    command: Option<Command>,
}

#[derive(Debug, Clone, Subcommand)]
enum Command {
    Account,
    Balance,
    VerifyNodeJsFiles,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let opt = Options::parse();

    opt.logging.init();

    if matches!(opt.command, Some(Command::VerifyNodeJsFiles)) {
        verify_node_js_files().await?;
        return Ok(());
    };

    let mut contracts = Contracts::from(opt.contracts);
    let provider = if opt.ledger {
        let signer = connect_ledger(opt.account_index as usize).await?;
        tracing::info!("Using ledger for signing, watch ledger device for prompts.");
        build_provider_ledger(signer, opt.rpc_url.clone(), Some(opt.l1_polling_interval))
    } else {
        build_provider(
            opt.mnemonic
                .expect("Mnemonic provided when not using ledger"),
            opt.account_index,
            opt.rpc_url.clone(),
            Some(opt.l1_polling_interval),
        )
    };

    // Fail early if we can't connect to the Ethereum RPC.
    let chain_id = provider.get_chain_id().await.with_context(|| {
        // The URL may contain a key in the query string.
        let mut url = opt.rpc_url.clone();
        url.set_query(None);
        format!("Unable query Ethereum provider {url}..")
    })?;
    tracing::info!("Connected to chain with chain ID: {chain_id}");

    let account = provider.default_signer_address();
    if let Some(command) = &opt.command {
        match command {
            Command::Account => {
                println!("{account}");
                return Ok(());
            },
            Command::Balance => {
                let balance = provider.get_balance(account).await?;
                println!("{account}: {} Eth", format_ether(balance));
                return Ok(());
            },
            _ => unreachable!(),
        };
    };

    // No subcommand specified. Deploy contracts.

    let balance = provider.get_balance(account).await?;
    tracing::info!(
        "Using deployer account {account} with balance: {}",
        format_ether(balance),
    );
    if balance.is_zero() {
        anyhow::bail!(
            "account_index {}, address={account} has no balance. A funded account is required.",
            opt.account_index
        );
    }

    // First use builder to build constructor input arguments
    let mut args_builder = DeployerArgsBuilder::default();
    args_builder
        .deployer(provider)
        .mock_light_client(opt.use_mock)
        .use_multisig(opt.use_multisig)
        .dry_run(opt.dry_run)
        .rpc_url(opt.rpc_url.to_string());
    if let Some(multisig) = opt.multisig_address {
        args_builder.multisig(multisig);
    }
    if let Some(multisig_pauser) = opt.multisig_pauser_address {
        args_builder.multisig_pauser(multisig_pauser);
    }
    if let Some(token_recipient) = opt.initial_token_grant_recipient {
        args_builder.token_recipient(token_recipient);
    }

    if let Some(blocks_per_epoch) = opt.blocks_per_epoch {
        args_builder.blocks_per_epoch(blocks_per_epoch);
    }
    if let Some(epoch_start_block) = opt.epoch_start_block {
        args_builder.epoch_start_block(epoch_start_block);
    }

    if opt.deploy_light_client_v1 {
        let (genesis_state, genesis_stake) = if opt.mock_espresso_live_network {
            light_client_genesis_from_stake_table(&Default::default(), DEFAULT_STAKE_TABLE_CAPACITY)
                .unwrap()
        } else {
            light_client_genesis(&opt.sequencer_url, opt.stake_table_capacity).await?
        };
        args_builder
            .genesis_lc_state(genesis_state)
            .genesis_st_state(genesis_stake);
        if let Some(prover) = opt.permissioned_prover {
            args_builder.permissioned_prover(prover);
        }
    }
    if opt.upgrade_light_client_v2 {
        let (blocks_per_epoch, epoch_start_block) =
            if (opt.dry_run && opt.use_multisig) || opt.mock_espresso_live_network {
                (10, 22)
            } else {
                // fetch epoch length from HotShot config
                // Request the configuration until it is successful
                loop {
                    match surf_disco::Client::<ServerError, StaticVersion<0, 1>>::new(
                        opt.sequencer_url.clone(),
                    )
                    .get::<PublicNetworkConfig>("config/hotshot")
                    .send()
                    .await
                    {
                        Ok(resp) => {
                            let config = resp.hotshot_config();
                            break (config.blocks_per_epoch(), config.epoch_start_block());
                        },
                        Err(e) => {
                            tracing::error!("Failed to fetch the network config: {e}");
                            sleep(Duration::from_secs(5));
                        },
                    }
                }
            };
        args_builder.blocks_per_epoch(blocks_per_epoch);
        args_builder.epoch_start_block(epoch_start_block);
    }

    if opt.deploy_stake_table {
        if let Some(escrow_period) = opt.exit_escrow_period {
            args_builder.exit_escrow_period(U256::from(escrow_period.as_secs()));
        }
    }
    if opt.deploy_timelock {
        let timelock_admin = opt
            .timelock_admin
            .expect("Must provide --timelock-admin when deploying timelock");
        args_builder.timelock_admin(timelock_admin);
        let timelock_delay = opt
            .timelock_delay
            .expect("Must provide --timelock-delay when deploying timelock");
        args_builder.timelock_delay(U256::from(timelock_delay));
        let timelock_executors = opt
            .timelock_executors
            .expect("Must provide --timelock-executors when deploying timelock");
        args_builder.timelock_executors(timelock_executors.into_iter().collect());
        let timelock_proposers = opt
            .timelock_proposers
            .expect("Must provide --timelock-proposers when deploying timelock");
        args_builder.timelock_proposers(timelock_proposers.into_iter().collect());
    }

    if opt.deploy_safe_exit_timelock {
        let safe_exit_timelock_admin = opt
            .safe_exit_timelock_admin
            .expect("Must provide --safe-exit-timelock-admin when deploying token timelock");
        args_builder.safe_exit_timelock_admin(safe_exit_timelock_admin);
        let safe_exit_timelock_delay = opt
            .safe_exit_timelock_delay
            .expect("Must provide --safe-exit-timelock-delay when deploying token timelock");
        args_builder.safe_exit_timelock_delay(U256::from(safe_exit_timelock_delay));
        let safe_exit_timelock_executors = opt
            .safe_exit_timelock_executors
            .expect("Must provide --safe-exit-timelock-executors when deploying token timelock");
        args_builder
            .safe_exit_timelock_executors(safe_exit_timelock_executors.into_iter().collect());
        let safe_exit_timelock_proposers = opt
            .safe_exit_timelock_proposers
            .expect("Must provide --safe-exit-timelock-proposers when deploying token timelock");
        args_builder
            .safe_exit_timelock_proposers(safe_exit_timelock_proposers.into_iter().collect());
    }

    // then deploy specified contracts
    let args = args_builder.build()?;
    if opt.deploy_fee {
        args.deploy(&mut contracts, Contract::FeeContractProxy)
            .await?;
    }
    if opt.deploy_esp_token {
        args.deploy(&mut contracts, Contract::EspTokenProxy).await?;
    }
    if opt.deploy_light_client_v1 {
        args.deploy(&mut contracts, Contract::LightClientProxy)
            .await?;
    }
    if opt.upgrade_light_client_v2 {
        args.deploy(&mut contracts, Contract::LightClientV2).await?;
    }
    if opt.deploy_stake_table {
        args.deploy(&mut contracts, Contract::StakeTableProxy)
            .await?;
    }
    if opt.upgrade_stake_table_v2 {
        args.deploy(&mut contracts, Contract::StakeTableV2).await?;
    }
    if opt.deploy_timelock {
        args.deploy(&mut contracts, Contract::Timelock).await?;
    }
    if opt.deploy_safe_exit_timelock {
        args.deploy(&mut contracts, Contract::SafeExitTimelock)
            .await?;
    }

    // finally print out or persist deployed addresses
    if let Some(out) = &opt.out {
        let file = File::options()
            .create(true)
            .truncate(true)
            .write(true)
            .open(out)?;
        contracts.write(file)?;
    } else {
        contracts.write(stdout())?;
    }

    Ok(())
}
