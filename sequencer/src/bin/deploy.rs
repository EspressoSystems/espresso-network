use std::{fs::File, io::stdout, path::PathBuf, thread::sleep, time::Duration};

use alloy::primitives::{Address, U256};
use clap::Parser;
use espresso_contract_deployer::{
    build_provider,
    builder::DeployerArgsBuilder,
    network_config::{light_client_genesis, light_client_genesis_from_stake_table},
    verify_node_js_files, Contract, Contracts, DeployedContracts,
};
use espresso_types::{config::PublicNetworkConfig, parse_duration};
use hotshot_types::light_client::DEFAULT_STAKE_TABLE_CAPACITY;
use sequencer_utils::logging;
use tide_disco::error::ServerError;
use url::Url;
use vbs::version::StaticVersion;

/// Deploy contracts needed to run the sequencer.
///
/// This script deploys contracts needed to run the sequencer to an L1. It outputs a .env file
/// containing the addresses of the deployed contracts.
///
/// This script can also be used to do incremental deployments. The only contract addresses
/// needed to configure the sequencer network are ESPRESSO_SEQUENCER_FEE_CONTRACT_PROXY_ADDRESS,
/// ESPRESSO_SEQUENCER_LIGHT_CLIENT_PROXY_ADDRESS and ESPRESSO_SEQUENCER_STAKE_TABLE_ADDRESS.
/// These contracts, however, have dependencies, and a full deployment involves several
/// contracts. Some of these contracts, especially libraries may already have been deployed, or
/// perhaps one of the top-level contracts has been deployed and we only need to deploy the other
/// one.
///
/// It is possible to pass in the addresses of already deployed contracts, in which case those
/// addresses will be used in place of deploying a new contract wherever that contract is required
/// in the deployment process. The generated .env file will include all the addresses passed in as
/// well as those newly deployed.
#[derive(Clone, Debug, Parser)]
struct Options {
    /// A JSON-RPC endpoint for the L1 to deploy to.
    #[clap(
        short,
        long,
        env = "ESPRESSO_SEQUENCER_L1_PROVIDER",
        default_value = "http://localhost:8545"
    )]
    rpc_url: Url,

    /// Request rate when polling L1.
    #[clap(
        long,
        env = "ESPRESSO_SEQUENCER_L1_POLLING_INTERVAL",
        default_value = "7s",
        value_parser = parse_duration,
    )]
    pub l1_polling_interval: Duration,

    /// URL of a sequencer node that is currently providing the HotShot config.
    /// This is used to initialize the stake table.
    #[clap(
        long,
        env = "ESPRESSO_SEQUENCER_URL",
        default_value = "http://localhost:24000"
    )]
    pub sequencer_url: Url,

    /// Mnemonic for an L1 wallet.
    ///
    /// This wallet is used to deploy the contracts, so the account indicated by ACCOUNT_INDEX must
    /// be funded with with ETH.
    #[clap(
        long,
        name = "MNEMONIC",
        env = "ESPRESSO_SEQUENCER_ETH_MNEMONIC",
        default_value = "test test test test test test test test test test test junk"
    )]
    mnemonic: String,

    /// Address for the multisig wallet that will be the admin
    ///
    /// If provided, this the multisig wallet that will be able to upgrade contracts and execute
    /// admin only functions on contracts. If not provided, admin power for all contracts will be
    /// held by the account used to deploy the contracts (determined from MNEMONIC, ACCOUNT_INDEX).
    #[clap(
        long,
        name = "MULTISIG_ADDRESS",
        env = "ESPRESSO_SEQUENCER_ETH_MULTISIG_ADDRESS"
    )]
    multisig_address: Option<Address>,

    /// Address for the multisig wallet that will be the pauser
    ///
    /// If provided, this the multisig wallet that will be able to upgrade contracts and execute
    /// admin only functions on contracts. If not provided, admin power for all contracts will be
    /// held by the account used to deploy the contracts (determined from MNEMONIC, ACCOUNT_INDEX).
    #[clap(
        long,
        name = "MULTISIG_PAUSER_ADDRESS",
        env = "ESPRESSO_SEQUENCER_ETH_MULTISIG_PAUSER_ADDRESS"
    )]
    multisig_pauser_address: Option<Address>,

    /// Account index in the L1 wallet generated by MNEMONIC to use when deploying the contracts.
    #[clap(
        long,
        name = "ACCOUNT_INDEX",
        env = "ESPRESSO_DEPLOYER_ACCOUNT_INDEX",
        default_value = "0"
    )]
    account_index: u32,

    /// Option to deploy fee contracts
    #[clap(long, default_value = "false")]
    deploy_fee: bool,
    /// Option to deploy LightClient V1 and proxy
    #[clap(long, default_value = "false")]
    deploy_light_client_v1: bool,
    /// Option to upgrade to LightClient V2
    #[clap(long, default_value = "false")]
    upgrade_light_client_v2: bool,
    /// Option to deploy esp token
    #[clap(long, default_value = "false")]
    deploy_esp_token: bool,
    /// Option to deploy stake table
    #[clap(long, default_value = "false")]
    deploy_stake_table: bool,
    #[clap(long, default_value = "false")]
    upgrade_stake_table_v2: bool,

    /// Write deployment results to OUT as a .env file.
    ///
    /// If not provided, the results will be written to stdout.
    #[clap(short, long, name = "OUT", env = "ESPRESSO_DEPLOYER_OUT_PATH")]
    out: Option<PathBuf>,

    #[clap(flatten)]
    contracts: DeployedContracts,

    /// If toggled, launch a mock LightClient contract with a smaller verification key for testing.
    /// Applies to both V1 and V2 of LightClient.
    #[clap(short, long)]
    pub use_mock: bool,

    /// Option to deploy contracts owned by multisig
    #[clap(long, default_value = "false")]
    pub use_multisig: bool,

    /// Option to test upgrade stake table v2 multisig owner dry run
    #[clap(long, default_value = "false")]
    pub dry_run: bool,

    /// Option to test locally but with a real eth network
    #[clap(long, default_value = "false")]
    pub mock_espresso_live_network: bool,

    /// Option to verify node js files access to upgrade stake table v2 multisig owner dry run
    #[clap(long, default_value = "false")]
    pub verify_node_js_files: bool,

    /// Stake table capacity for the prover circuit
    #[clap(short, long, env = "ESPRESSO_SEQUENCER_STAKE_TABLE_CAPACITY", default_value_t = DEFAULT_STAKE_TABLE_CAPACITY)]
    pub stake_table_capacity: usize,
    ///
    /// If the light client contract is being deployed and this is set, the prover will be
    /// permissioned so that only this address can update the light client state. Otherwise, proving
    /// will be permissionless.
    ///
    /// If the light client contract is not being deployed, this option is ignored.
    #[clap(long, env = "ESPRESSO_SEQUENCER_PERMISSIONED_PROVER")]
    permissioned_prover: Option<Address>,

    /// Exit escrow period for the stake table contract.
    ///
    /// This is the period for which stake table contract will retain funds after withdrawals have
    /// been requested. It should be set to a value that is at least 3 hotshot epochs plus ample
    /// time to allow for submission of slashing evidence. Initially it will probably be around one
    /// week.
    #[clap(long, env = "ESPRESSO_SEQUENCER_STAKE_TABLE_EXIT_ESCROW_PERIOD", value_parser = parse_duration)]
    exit_escrow_period: Option<Duration>,

    /// The address that the tokens will be minted to.
    ///
    /// If unset the tokens will be minted to the deployer account.
    #[clap(long, env = "ESP_TOKEN_INITIAL_GRANT_RECIPIENT_ADDRESS")]
    initial_token_grant_recipient: Option<Address>,

    /// The blocks per epoch    
    #[clap(long, env = "ESPRESSO_SEQUENCER_BLOCKS_PER_EPOCH")]
    blocks_per_epoch: Option<u64>,

    /// The epoch start block
    #[clap(long, env = "ESPRESSO_SEQUENCER_EPOCH_START_BLOCK")]
    epoch_start_block: Option<u64>,
    /// The initial supply of the tokens.
    #[clap(long, env = "ESP_TOKEN_INITIAL_SUPPLY", default_value_t = U256::from(3590000000u64))]
    initial_token_supply: U256,

    /// The name of the tokens.
    #[clap(long, env = "ESP_TOKEN_NAME", default_value = "Espresso")]
    token_name: String,

    /// The symbol of the tokens.
    #[clap(long, env = "ESP_TOKEN_SYMBOL", default_value = "ESP")]
    token_symbol: String,

    #[clap(flatten)]
    logging: logging::Config,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let opt = Options::parse();
    opt.logging.init();

    if opt.verify_node_js_files {
        verify_node_js_files().await?;
    }

    let mut contracts = Contracts::from(opt.contracts);
    let provider = build_provider(opt.mnemonic, opt.account_index, opt.rpc_url.clone());

    // First use builder to build constructor input arguments
    let mut args_builder = DeployerArgsBuilder::default();
    args_builder
        .deployer(provider)
        .mock_light_client(opt.use_mock)
        .use_multisig(opt.use_multisig)
        .dry_run(opt.dry_run)
        .rpc_url(opt.rpc_url.to_string());
    if let Some(multisig) = opt.multisig_address {
        args_builder.multisig(multisig);
    }
    if let Some(multisig_pauser) = opt.multisig_pauser_address {
        args_builder.multisig_pauser(multisig_pauser);
    }
    if let Some(token_recipient) = opt.initial_token_grant_recipient {
        args_builder.token_recipient(token_recipient);
    }

    if let Some(blocks_per_epoch) = opt.blocks_per_epoch {
        args_builder.blocks_per_epoch(blocks_per_epoch);
    }
    if let Some(epoch_start_block) = opt.epoch_start_block {
        args_builder.epoch_start_block(epoch_start_block);
    }

    if opt.deploy_light_client_v1 {
        let (genesis_state, genesis_stake) = if opt.mock_espresso_live_network {
            light_client_genesis_from_stake_table(&Default::default(), DEFAULT_STAKE_TABLE_CAPACITY)
                .unwrap()
        } else {
            light_client_genesis(&opt.sequencer_url, opt.stake_table_capacity).await?
        };
        args_builder
            .genesis_lc_state(genesis_state)
            .genesis_st_state(genesis_stake);
        if let Some(prover) = opt.permissioned_prover {
            args_builder.permissioned_prover(prover);
        }
    }
    if opt.upgrade_light_client_v2 {
        let (blocks_per_epoch, epoch_start_block) =
            if (opt.dry_run && opt.use_multisig) || opt.mock_espresso_live_network {
                (10, 22)
            } else {
                // fetch epoch length from HotShot config
                // Request the configuration until it is successful
                loop {
                    match surf_disco::Client::<ServerError, StaticVersion<0, 1>>::new(
                        opt.sequencer_url.clone(),
                    )
                    .get::<PublicNetworkConfig>("config/hotshot")
                    .send()
                    .await
                    {
                        Ok(resp) => {
                            let config = resp.hotshot_config();
                            break (config.blocks_per_epoch(), config.epoch_start_block());
                        },
                        Err(e) => {
                            tracing::error!("Failed to fetch the network config: {e}");
                            sleep(Duration::from_secs(5));
                        },
                    }
                }
            };
        args_builder.blocks_per_epoch(blocks_per_epoch);
        args_builder.epoch_start_block(epoch_start_block);
    }

    if opt.deploy_stake_table {
        if let Some(escrow_period) = opt.exit_escrow_period {
            args_builder.exit_escrow_period(U256::from(escrow_period.as_secs()));
        }
    }

    // then deploy specified contracts
    let args = args_builder.build()?;
    if opt.deploy_fee {
        args.deploy(&mut contracts, Contract::FeeContractProxy)
            .await?;
    }
    if opt.deploy_esp_token {
        args.deploy(&mut contracts, Contract::EspTokenProxy).await?;
    }
    if opt.deploy_light_client_v1 {
        args.deploy(&mut contracts, Contract::LightClientProxy)
            .await?;
    }
    if opt.upgrade_light_client_v2 {
        args.deploy(&mut contracts, Contract::LightClientV2).await?;
    }
    if opt.deploy_stake_table {
        args.deploy(&mut contracts, Contract::StakeTableProxy)
            .await?;
    }
    if opt.upgrade_stake_table_v2 {
        args.deploy(&mut contracts, Contract::StakeTableV2).await?;
    }

    // finally print out or persist deployed addresses
    if let Some(out) = &opt.out {
        let file = File::options()
            .create(true)
            .truncate(true)
            .write(true)
            .open(out)?;
        contracts.write(file)?;
    } else {
        contracts.write(stdout())?;
    }

    Ok(())
}
