use std::time::Duration;

use espresso_types::{NamespaceId, NsProof, PubKey};
use futures::{try_join, FutureExt};
use hotshot_query_service::{
    availability::{
        self, AvailabilityDataSource, BlockQueryData, Error, FetchBlockSnafu, VidCommonQueryData,
    },
    node::NodeDataSource,
    types::HeightIndexed,
    ApiState,
};
use hotshot_types::{
    data::VidShare,
    traits::{network::ConnectedNetwork, node_implementation::Versions},
    vid::avidm::AvidMShare,
};
use snafu::OptionExt;
use tide_disco::{Api, RequestParams, StatusCode};
use tracing::warn;
use vbs::version::StaticVersionType;

use crate::{
    api::{
        data_source::{RequestResponseDataSource, SequencerDataSource},
        StorageState,
    },
    SeqTypes, SequencerApiVersion, SequencerPersistence,
};

pub(in crate::api) type AvailState<N, P, D, ApiVer> = ApiState<StorageState<N, P, D, ApiVer>>;

type AvailabilityApi<N, P, D, V, ApiVer> = Api<AvailState<N, P, D, V>, Error, ApiVer>;

/// Get a namespace proof for the given block, if possible.
///
/// Always returns the newest supported proof type, which supports the greatest number of possible
/// cases (e.g. proofs can still be generated even if the block was maliciously encoded). For
/// backwards compatibility, the resulting proof can be downgraded. However, this may fail in case a
/// proof was only able to be generated by making use of one of the newer proof types.
///
/// Returns no proof (`Ok(None)`) if the requested namespace is not present at all in the given
/// block.
async fn get_namespace_proof(
    block: &BlockQueryData<SeqTypes>,
    common: &VidCommonQueryData<SeqTypes>,
    ns_id: NamespaceId,
    state: &(impl AvailabilityDataSource<SeqTypes>
          + NodeDataSource<SeqTypes>
          + RequestResponseDataSource<SeqTypes>),
) -> Result<Option<NsProof>, Error> {
    let ns_table = block.payload().ns_table();
    let Some(ns_index) = ns_table.find_ns_id(&ns_id) else {
        return Ok(None);
    };

    // Optimistically, try to generate a
    // proof for a correctly encoded block.
    if let Some(proof) = NsProof::new(block.payload(), &ns_index, common.common()) {
        return Ok(Some(proof));
    }

    // If we fail to generate the correct encoding proof, try to generate a v1.1 proof, which
    // supports proof of incorrect encoding.
    tracing::warn!(
        height = block.height(),
        ?ns_id,
        "Failed to generate namespace proof, trying to generate incorrect encoding proof"
    );
    let mut vid_shares = state
        .request_vid_shares(block.height(), common.clone(), Duration::from_secs(40))
        .await
        .map_err(|err| {
            warn!("Failed to request VID shares from network: {err:#}");
            hotshot_query_service::availability::Error::Custom {
                message: "Failed to request VID shares from network".to_string(),
                status: StatusCode::NOT_FOUND,
            }
        })?;
    let vid_share = state.vid_share(block.height() as usize).await;
    if let Ok(vid_share) = vid_share {
        vid_shares.push(vid_share);
    };

    // Collect the shares as V1 shares
    let vid_shares: Vec<AvidMShare> = vid_shares
        .into_iter()
        .filter_map(|share| {
            if let VidShare::V1(share) = share {
                Some(share)
            } else {
                None
            }
        })
        .collect();

    if let Some(proof) = NsProof::v1_1_new_with_incorrect_encoding(
        &vid_shares,
        ns_table,
        &ns_index,
        &common.payload_hash(),
        common.common(),
    ) {
        return Ok(Some(proof));
    }

    Err(Error::Custom {
        message: "Failed to generate proof of incorrect encoding".to_string(),
        status: StatusCode::INTERNAL_SERVER_ERROR,
    })
}

async fn get_ns_proof_v1(
    block: &BlockQueryData<SeqTypes>,
    common: &VidCommonQueryData<SeqTypes>,
    ns_id: NamespaceId,
    state: &(impl AvailabilityDataSource<SeqTypes>
          + NodeDataSource<SeqTypes>
          + RequestResponseDataSource<SeqTypes>),
) -> Result<espresso_types::NamespaceProofQueryData, Error> {
    let proof = get_namespace_proof(block, common, ns_id, state).await?;
    let transactions = proof
        .as_ref()
        .map(|proof| proof.export_all_txs(&ns_id))
        .unwrap_or_default();
    Ok(espresso_types::NamespaceProofQueryData {
        transactions,
        proof,
    })
}

async fn get_ns_proof_v0(
    block: &BlockQueryData<SeqTypes>,
    common: &VidCommonQueryData<SeqTypes>,
    ns_id: NamespaceId,
    state: &(impl AvailabilityDataSource<SeqTypes>
          + NodeDataSource<SeqTypes>
          + RequestResponseDataSource<SeqTypes>),
) -> Result<espresso_types::ADVZNamespaceProofQueryData, Error> {
    let proof = match get_namespace_proof(block, common, ns_id, state).await? {
        Some(NsProof::V0(proof)) => Some(proof),
        Some(_) => {
            return Err(Error::Custom {
                message: "Unsupported VID version, use new API version instead.".to_string(),
                status: StatusCode::NOT_FOUND,
            })
        },
        None => None,
    };
    let transactions = proof
        .as_ref()
        .map(|proof| proof.export_all_txs(&ns_id))
        .unwrap_or_default();
    Ok(espresso_types::ADVZNamespaceProofQueryData {
        transactions,
        proof,
    })
}

async fn get_block_for_ns_proof(
    req: &RequestParams,
    state: &impl AvailabilityDataSource<SeqTypes>,
    timeout: Duration,
) -> Result<(BlockQueryData<SeqTypes>, VidCommonQueryData<SeqTypes>), Error> {
    let height: usize = req.integer_param("height")?;
    try_join!(
        async move {
            state
                .get_block(height)
                .await
                .with_timeout(timeout)
                .await
                .context(FetchBlockSnafu {
                    resource: height.to_string(),
                })
        },
        async move {
            state
                .get_vid_common(height)
                .await
                .with_timeout(timeout)
                .await
                .context(FetchBlockSnafu {
                    resource: height.to_string(),
                })
        }
    )
}

// TODO (abdul): replace snafu with `this_error` in  hotshot query service
// Snafu has been replaced by `this_error` everywhere.
// However, the query service still uses snafu
pub(in crate::api) fn availability<N, P, D, V: Versions>(
    api_ver: semver::Version,
) -> anyhow::Result<AvailabilityApi<N, P, D, V, SequencerApiVersion>>
where
    N: ConnectedNetwork<PubKey>,
    D: SequencerDataSource + Send + Sync + 'static,
    P: SequencerPersistence,
{
    let mut options = availability::Options::default();
    let extension = toml::from_str(include_str!("../../../api/availability.toml"))?;
    options.extensions.push(extension);
    let timeout = options.fetch_timeout;

    let mut api = availability::define_api::<AvailState<N, P, D, _>, SeqTypes, _>(
        &options,
        SequencerApiVersion::instance(),
        api_ver.clone(),
    )?;

    if api_ver.major == 1 {
        api.get("getnamespaceproof", move |req, state| {
            async move {
                let ns_id = NamespaceId::from(req.integer_param::<_, u32>("namespace")?);
                let (block, common) = get_block_for_ns_proof(&req, state, timeout).await?;
                get_ns_proof_v1(&block, &common, ns_id, state).await
            }
            .boxed()
        })?;
    } else if api_ver.major == 0 {
        api.get("getnamespaceproof", move |req, state| {
            async move {
                let ns_id = NamespaceId::from(req.integer_param::<_, u32>("namespace")?);
                let (block, common) = get_block_for_ns_proof(&req, state, timeout).await?;
                get_ns_proof_v0(&block, &common, ns_id, state).await
            }
            .boxed()
        })?;
    }

    if api_ver.major >= 1 {
        api.get("incorrect_encoding_proof", move |req, state| {
            async move {
                let ns_id = NamespaceId::from(req.integer_param::<_, u32>("namespace")?);
                let (block, common) = get_block_for_ns_proof(&req, state, timeout).await?;
                match get_namespace_proof(&block, &common, ns_id, state).await? {
                    Some(NsProof::V1IncorrectEncoding(proof)) => Ok(proof),
                    Some(_) => Err(Error::Custom {
                        message: "block was correctly encoded".into(),
                        status: StatusCode::NOT_FOUND,
                    }),
                    None => Err(Error::Custom {
                        message: "namespace not present in block".into(),
                        status: StatusCode::NOT_FOUND,
                    }),
                }
            }
            .boxed()
        })?;
    }

    Ok(api)
}
