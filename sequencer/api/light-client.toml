[route.leaf]
PATH = [
    "/leaf/:height",
    "/leaf/:height/:finalized",
    "/leaf/hash/:hash",
    "/leaf/hash/:hash/:finalized",
    "/leaf/block-hash/:block-hash",
    "/leaf/block-hash/:block-hash/:finalized",
    "/leaf/payload-hash/:payload-hash",
    "/leaf/payload-hash/:payload-hash/:finalized",
]
":height" = "Integer"
":finalized" = "Integer"
":hash" = "TaggedBase64"
":block-hash" = "TaggedBase64"
":payload-hash" = "TaggedBase64"
DOC = """
Fetch a leaf plus a proof of it's finality (a chain of leaves leading from that leaf to either a
chain of consecutive valid QCs or a known-finalized leaf).

`:height` and `:finalized`, if provided, must both be block numbers. If provided, `:finalized` must
be greater than `:height`.

The returned proof contains the requested leaf along with sufficient other leaves/QCs to prove the
requested leaf is finalized (possibly assuming that the leaf at height `:finalized` is already known
to be finalized). This consists of a chain of valid leaves from the requested leaf until reaching
either
* a 2-chain of QCs (if the last leaf in the leaf chain is from HotShot >= 0.3)
* a 3-chain of QCs (if the last leaf in the leaf chain is from HotShot < 0.3)
* the assumed `:finalized` leaf

Returns
```json
{
    "leaves": [Leaf],
    "proof": {
        // Finality proof for HotShot >= 0.3
        "HotStuff2": {
            "committing_qc": QC,
            "deciding_qc": QC
        } | undefined,

        // Finality proof for HotShot < 0.3
        "HotStuff": {
            "precommit_qc": QC,
            "committing_qc": QC,
            "deciding_qc": QC
        } | undefined,

        // Leaf chain ends in assumed-finalized leaf.
        "Assumption": {}
    }
}
```
"""

[route.header]
PATH = [
    "/header/:root/:height",
    "/header/:root/hash/:hash",
    "/header/:root/payload-hash/:payload-hash",
]
":root" = "Integer"
":height" = "Integer"
":hash" = "TaggedBase64"
":payload-hash" = "TaggedBase64"
DOC = """
Fetch a header plus a proof of it's inclusion in the blocks Merkle tree.

Returns the header identified by `:height`, `:hash`, or `:payload-hash`, plus a Merkle proof showing
it belongs to the Merkle tree rooted in the header at height `:root` (`:height` < `:root`).

Returns
```json
{
    "header": Header,
    "proof": MerkleProof
}
```
"""

[route.stake_table]
PATH = ["/stake-table/:epoch"]
":epoch" = "Integer"
DOC = """
Get events needed to construct the stake table for the given epoch.

This endpoint assumes the client already has the full `StakeTableState` for epoch `:epoch - 1`. It
returns just the list of events required to transform `:epoch - 1` stake table into `:epoch` stake
table.

The resulting stake table can be verified by computing its hash, fetching the header for the epoch
root of `:epoch`, and comparing against the hash in the header.

Returns
```json
[StakeTableEvent]
```
"""

[route.payload]
PATH = [
    "/payload/:height",
    "/payload/hash/:hash",
    "/payload/payload-hash/:payload-hash",
]
":height" = "Integer"
":hash" = "TaggedBase64"
":payload-hash" = "TaggedBase64"
DOC = """
Fetch a payload plus the VID common data needed to recompute and verify its hash.
"""
