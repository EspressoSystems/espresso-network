#!/usr/bin/env bash
set -euxo pipefail

export ESPRESSO_SEQUENCER_POSTGRES_HOST=${ESPRESSO_SEQUENCER_POSTGRES_HOST:-localhost}
export ESPRESSO_SEQUENCER_POSTGRES_PORT=${ESPRESSO_SEQUENCER_POSTGRES_PORT:-5432}
export ESPRESSO_SEQUENCER_POSTGRES_USER=${ESPRESSO_SEQUENCER_POSTGRES_USER:-root}
export ESPRESSO_SEQUENCER_POSTGRES_PASSWORD=${ESPRESSO_SEQUENCER_POSTGRES_PASSWORD:-password}

export POSTGRES_USER=$ESPRESSO_SEQUENCER_POSTGRES_USER
export POSTGRES_PASSWORD=$ESPRESSO_SEQUENCER_POSTGRES_PASSWORD

export RUST_LOG=${RUST_LOG:-info}

# Function to handle SIGTERM and SIGINT
cleanup() {
    echo "Received SIGTERM or SIGINT. Exiting..."
    kill -TERM "$postgres_pid" 2>/dev/null
    kill -TERM "$dev_node_pid" 2>/dev/null
    wait "$postgres_pid"
    wait "$dev_node_pid"
    exit 0
}

# Trap SIGTERM and SIGINT signals
trap cleanup SIGTERM SIGINT

# Start postgres in the background
docker-entrypoint.sh postgres &
postgres_pid=$!

# Wait (twice) for postgres to be ready
# Postgres can be falsely "ready" once before running init scripts.
until pg_isready && sleep 1 && pg_isready; do
  echo "Waiting for postgres..."
  sleep 1
done

# Start the dev node
espresso-dev-node &
dev_node_pid=$!

# Wait for child processes to exit
wait "$postgres_pid"
wait "$dev_node_pid"
