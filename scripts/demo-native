#!/usr/bin/env bash
set -euo pipefail

# Parse --release flag
use_release=0
pc_args=()
for arg in "$@"; do
	if [[ "$arg" == "--release" ]]; then
		use_release=1
	else
		pc_args+=("$arg")
	fi
done

REPO_ROOT="$(dirname "$(dirname "$(readlink -fm "$0")")")"
# Default to CARGO_TARGET_DIR if set, otherwise use the default target directory.
TARGET_DIR="${CARGO_TARGET_DIR:-${REPO_ROOT}/target}"

if [[ "$use_release" -eq 1 ]]; then
	echo -e "Appending ${TARGET_DIR}/release to PATH.\n"
	export "PATH=${TARGET_DIR}/release:$PATH"
elif [[ -z "${IN_NIX_SHELL-}" ]]; then
    # The nix shell already sets the PATH to include the debug binaries.
	export "PATH=${TARGET_DIR}/debug:$PATH"
    echo -e "Appending ${TARGET_DIR}/debug to PATH.\n"
fi

ESPRESSO_BASE_STORAGE_PATH=$(mktemp -d -t espresso-XXXXXXXX)
export ESPRESSO_BASE_STORAGE_PATH
echo "Using sequencer storage path: $ESPRESSO_BASE_STORAGE_PATH"

cleanup() {
	# Don't run cleanup if running in the CI. We may be running process-compose
	# with --detach and the cleanup will remove the storage path while the
	# services are still running.
	CI=${CI:-false}
	if [[ "$CI" = "true" ]]; then
		echo "Running in CI, not cleaning up $ESPRESSO_BASE_STORAGE_PATH"
	else
		echo "Cleaning up sequencer storage path: $ESPRESSO_BASE_STORAGE_PATH"
		rm -rv "$ESPRESSO_BASE_STORAGE_PATH"

		SCRIPT_DIR="$(dirname "$(readlink -fm "$0")")"
		"$SCRIPT_DIR/cleanup-process-compose"
	fi
}

# If keeping the storage path is desired, run with env CI=true Forward signals to process-compose
# child process
trap 'kill -TERM "$PC_PID" 2>/dev/null || true' INT TERM
trap 'cleanup' EXIT

process-compose "${pc_args[@]}" &
PC_PID=$!
wait "$PC_PID"                     # Interrupted by signal, trap runs
wait "$PC_PID" 2>/dev/null || true # Actually wait for process-compose to exit
